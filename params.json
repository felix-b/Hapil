{"name":"Happil","tagline":"A Reflection.Emit wrapper for dynamic implementation of interfaces and abstract classes, which just works and keeps its users happy.","body":"### Welcome to Happil\r\nIn this project we aim to create a wrapper library around .NET Reflection.Emit API. The library should precisely fit two use cases of run-time type generation, which we have in mind:\r\n\r\n* **Implementation**: Given a compiled interface or an abstract class, generate its fully functional implementation at run-time.\r\n* **Interception**: Decorate objects at run-time for the handling of cross-cutting concerns.\r\n\r\nWe also have two important qualities in mind:\r\n\r\n* Being **easy**: provide happy path for the two use cases; make it hard to create an invalid program.\r\n* Being **lightweight**: generated programs should contain no inherent overhead and consume as little CPU cycles and memory as possible, even in large applications having thousands of interfaces to implement or intercept.\r\n\r\n### Alternatives to Happil\r\nThe motivation to launch this project comes from our experience trying to get things done with existing alternatives, namely:\r\n* **Castle DynamicProxy** is an awesome library which provides an elegant, simple, and yet powerful way of decorating objects at runtime. Unfortunately, it is only good for the interception use case; implementing interfaces from scratch is not its home ground. Another concern is that it generates an invocation class for each member of each decorated type. In a large application, this can lead to generating tens of thousands of types - which is not really that lightweight.\r\n* **RunSharp** is another great tool which allows creation of arbitrary dynamic types and code at run-time. It allows too much freedom though, which in the bottom line, makes it harder to implement either of our two use cases. With RunSharp, we feel it is too easy to make a mistake and generate an incorrect program. This library also has stability issues, from our experience, and it also looks like it is not longer maintained.\r\n* **FluentIL** is a cute library which wraps the Reflection.Emit API. But again, the API it provides is too a low level, and it again makes it harder to achieve the two use cases.\r\n\r\n## Show Me The Money\r\n\r\n**Three** - given an interface of a data transfer object:\r\n\r\n```csharp\r\npublic interface ICustomer\r\n{\r\n  int Id { get; set; }\r\n  string FullName { get; set; }\r\n  string EmailAddress { get; set; }\r\n}\r\n```\r\n\r\n**Two** - plus an implementation convention:\r\n\r\n```csharp\r\nDeriveClassFrom<object>()\r\n  .ImplementInterface<ICustomer>()\r\n  .AllProperties().ImplementAutomatic();\r\n```\r\n\r\n**One** - plus a decorator convention:\r\n\r\n```csharp\r\npublic class DataContractDecorator : ClassDecoratorBase\r\n{\r\n  public override void OnClassType(ClassType classType, ClassWriterBase writer)\r\n  {\r\n    writer.Attribute<DataContractAttribute>(values => values.Named(a => a.Namespace, \"http://mydto/customer\"));\r\n  }\r\n  public override void OnProperty(PropertyMember member, Func<PropertyDecorationBuilder> decorate)\r\n  {\r\n    decorate().Attribute<DataMemberAttribute>();\r\n  }\r\n}\r\n```\r\n\r\n**GO!**\r\n\r\n```csharp\r\n[DataContract(Namespace = \"http://mydto/customer\")]\r\npublic sealed class CustomerDto : ICustomer\r\n{\r\n\tprivate int m_Id;\r\n\tprivate string m_FullName;\r\n\tprivate string m_EmailAddress;\r\n\r\n\t[DataMember]\r\n\tpublic int Id\r\n\t{\r\n\t\tget { return this.m_Id; }\r\n\t\tset { this.m_Id = value; }\r\n\t}\r\n\r\n\t[DataMember]\r\n\tpublic string FullName\r\n\t{\r\n\t\tget { return this.m_FullName; }\r\n\t\tset { this.m_FullName = value; }\r\n\t}\r\n\r\n\t[DataMember]\r\n\tpublic string EmailAddress\r\n\t{\r\n\t\tget { return this.m_EmailAddress; }\r\n\t\tset { this.m_EmailAddress = value; }\r\n\t}\r\n}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}